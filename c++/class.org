* 类
C++ 中,用类来定义自己的抽象数据类型(abstract data types)。
** 类的定义和声明
*** 类定义： 扼要重述
最简单的说，类就是定义了一个新的类型和新作用域。
 + 类成员
   每个类可以没有成员，也可以定义多个成员,成员可以是数据、函数或类型别名。
 + 构造函数
   创建一个类类型的对象时,编译器会自动使用一个构造函数(第 2.3.3 节)来初始化该对象。构造函数是一个特殊的、与类同名的成员函数,用于给每个数据成员设置适当的初始值。
 + 成员函数
   在类内部,声明成员函数是必需的,而定义成员函数则是可选的。在类内部定义的函数默认为 inline。
*** 数据抽象和封装
类背后蕴涵的基本思是数据抽象和封装

*数据抽象* 是一种依赖于接口和实现分离的编程(和设计)技术。类设计者必须关心类是如何实现的,但使用该类的程序员不必了解这些细节。

*封装* 是一项低层次的元素组合起来的形成新的、高层次实体珠技术。函数是封装的一种形式:函数所执行的细节行为被封装在函数本身这个更大的实体中。
被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。

*访问标号实施抽象和封装*

在 C++ 中，使用访问标号来定义类的抽象接口和实施封装。一个类可以没有访问标号，也可以包含多个访问标号。
 + 程序的所有部分都可以访问带有 public 标号的成员。类型的数据抽象视图由其 public 成员定义。
 + 使用类的代码不可以访问带有 private 标号的成员。private 封装了类型的实现细节。


编程角色的不同类别
*** 关于类定义的更多内容
**** 同一类型的多个数据成员
**** 成员函数可被重载
**** 定义重载成员函数
**** 显示指定inline成员函数
在类内部定义的成员函数,将自动作为inline 处理。也就是说,当它们被调用时,编译器将试图在同一行内扩展该函数
*** 类声明与类定义
一旦遇到右花括号,类的定义就结束了。并且一旦定义了类,那以我们就知道了所有的类成员,以及存储该类的对象所需的存储空间。在一个给定的源文件
中,一个类只能被定义一次。如果在多个文件中定义一个类,那么每个文件中的定义必须是完全相同的。
*** 类对象
定义一个类时,也就是定义了一个类型。
一旦定义了类,就可以定义该类型的对象。定义对象时,将为其分配存储空间,但(一般而言)定义类型时不进行存储分配:
**** 定义类类型的对象
定义了一个类类型之后,可以按照以下两种方式使用。
 + 将类的名字直接用作类型名
 + 指定关键字 class 或 struct,后面跟着类的名字

****  为什么类的定义以分号结束
类的定义分号结束。因为在类定义之后可以接一个对象定义列表。
#+BEGIN_EXAMPLE
  class Sales_item { /* ... */ };
  class Sales_item { /* ... */ } accum, trans;
#+END_EXAMPLE

#+BEGIN_QUOTE
通常,将对象定义成类定义的一部分是个坏主意。这样做,会使所发生的操作难以理解。对读者而言,将两个
不同的实体(类和变量)组合在一个语句中,也会令人迷惑不解。
#+END_QUOTE

** 隐含的 this 指针

*何时使用 this 指针：*
 当我们需要将一个对象最为整体引用而不是引用对象的一个成员时。最常件的情况是这样的函数中使用this：再函数返回对调用改函数的对象的引用。

*返回 *this*
 
*从 const 成员函数返回 *this*
在普通的非 const 成员函数中,this 的类型是一个指向类类型的 const指针。在 const 成员函数中,this 的类型是一个指向 const 类类型对象的const 指针。
既不能改变 this 所指向的对象,也不能改变 this 所保存的地址



*基于 const 的重载*

*可变数据成员*

** 类作用域
#+BEGIN_QUOTE
即使两个类具有完全相同的成员列表,它们也是不同的类型。每个类的成员不同于任何其他类(或任何其他作用域)的成员。

#+END_QUOTE

*** 使用类的成员
在类作用域之外,成员只能通过对象或指针分别使用成员访问操作符 . 或-> 来访问。这些操作符左边的操作数分别是一个类对象或指向类对象的指针。跟在操作符后面的成员名字必须在相关联的类的作用域中声明。

一些成员使用成员访问操作符来访问,另一些直接通过类使用作用域操作符(::)来访问。一般的数据或函数成员必须通过对象来访问。定义类型的成员,如 Screen::index,使用作用域操作符来访问。

*** 作用域与成员定义

*** 形参表和函数体处于类作用域中
在定义于类外部的成员函数中,形参表和成员函数体都出现在成员名之后。这些都是在类作用域中定义,所以可以不用限定而引用其他成员。

*** 类作用域中的名字查找


** 构造函数 
构造函数是特殊的成员函数,只要创建类类型的新对象,都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。

构造函数的名字与类的名字相同,并且不能指定返回类型。像其他任何函数一样,它们可以没有形参,也可以定义多个形参。

*** 构造函数可以被重载


** 友元
友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现
在类中的任何地方:友元不是授予友元关系的那个类的成员,所以它们不受声明出现部分的访问控制影响。


友元可以是普通的非成员函数,或前面定义的其他类的成员函数,或整个类。将一个类设为友元,友元类的所有成员函数都可以访问授予友元关系的那个类的非公有成员。

*** 使其他类的成员函数成为友元

*** 友元和作用域

*** 使用类的 static 成员的优点
使用static成员而不是全局对象有三个优点：
 + static成员的名字在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。
 + 可以实施封装。 static 成员可以是私有成员，而全局对象不可以。
 + 通过阅读程序容易看出 static 成员是与特定类关联的。这种可见性可清晰地显示程序员的意图。

*** 定义 static 成员
在成员声明前加上关键字 static 将成员设为 static。static 成员遵循正常的公有/私有访问规则。

