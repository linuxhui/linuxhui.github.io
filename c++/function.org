* 函数
本章将介绍函数的定义和声明。其中讨论了如何给函数传递参数以及如何从函数返回值。然后具体分析三类特殊的函数:内联(inline)函数、类成员函数和重载函数。最后以一个更高级的话题“函数指针”来结束全章
** 函数的定义
函数由函数名以及一组操作数类型唯一地表示。函数的操作数,也即形参,在一对圆括号中声明,形参与形参之间以逗号分隔。函数执行的运算在一个称为函数体的块语句中定义。每一个函数都有一个相关联的返回类型。
*** 函数的调用
C++ 语言使用调用操作符(即一对圆括号)实现函数的调用。调用操作符的操作数是函数名和一组(有可能是空的)由逗号分隔的实参。
函数调用的结果类型就是函数返回值的类型,该运算的结果本身就是函数的返回值
*** 函数体是一个作用域
函数体是一个语句块,定义了函数的具体操作。通常,这个块语句包含在一对花括号中,形成了一个新的作用域。和其他的块语句一样,在函数体中可以定义变量。
在函数体内定义的变量只在该函数中才可以访问。这种变量称为局部变量, 这种变量只在函数运行时存在。
*** 形参和实参                                                     :没搞懂:
类似于局部变量,函数的形参为函数提供了已命名的局部存储空间。它们之间的差别在于形参是在函数的形参表中定义的,并由调用函数时传递函数的实参初始化。
** 函数返回值类型
函数的返回类型可以是内置类型(如 int 或者 double)、类类型或复合类型(如int& 或 string*),还可以是 void 类型,表示该函数不返回任何值。

函数不能返回另一个函数或者内置数组类型,但可以返回指向函数的指针,或指向数组元素的指针的指针
*** 函数必须指定返回类型
在 *定义* 或 *声明* 函数时,没有显式指定返回类型是不合法的。

** 函数形参表
函数形参表可以为空,但不能省略。没有任何形参的函数可以用空形参表或含有单个关键字 void 的形参表来表示。
#+BEGIN_EXAMPLE
  void process() { /* ... */ } // implicit void parameter list
  void process(void){ /* ... */ } // equivalent declaration
#+END_EXAMPLE

形参表由一系列用逗号分隔的参数类型和(可选的)参数名组成。如果两个参数具有相同的类型,则其类型必须重复声明:
#+BEGIN_EXAMPLE
  int manip(int v1, v2) { /* ... */ }                   // WRONG
  int manip(int v1, int v2) { /* ... */ }               // OK
#+END_EXAMPLE
*** 参数类型检查
C++ 是一种静态强类型语句,对于每一次的函数调用,编译时都会检查其实参。

** 参数传递
每次调用函数时,都会重新创建该函数所有的形参,此时所传递的实参将会初始化对应的形参。

#+BEGIN_QUOTE
形参的初始化与变量的初始化一样:如果形参具有非引用类型,
则复制实参的值,如果形参为引用类型(第 2.5 节),则它只
是实参的别名。
#+END_QUOTE

*** 非引用形参
普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时,函数并没有访问调用所传递的实参本身,因此不会修改实参的值。

**** 指针形参
函数的形参可以是指针,此时将复制实参指针。与其他非引用类型的形参一样,该类形参的任何改变也仅作用于局部副本。如果函数将新指针赋给形参,主调函数使用的实参指针的值没有改变。

**** const 形参 
在调用函数时,如果该函数使用非引用的非 const 形参,则既可给该函数传递 const 实参也可传递非 const 的实参。

**** 利用 const 引用避免赋值
虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题,但是对于大部分的类类型或者大型数组,它的效率(通常)太低了。

使用const 引用就可以避免复制。


**** 更灵活的指向 const 的引用
如果函数具有普通的非 const 引用形参,则显然不能通过 const 对象进行调用。毕竟,此时函数可以修改传递进来的对象,这样就违背了实参的 const 特性。

**** 传递指向指针的引用

*** 数组形参
数组有两个特殊的性质,影响我们定义和使用作用在数组上的函数:一是不能复制数组;二是使用数组名字时,数组名会自动转化为指向其第一个元素的指针。

**** 数组形参的定义
如果编写一个函数，输出 int 型数组的内容，可用下面三种方式指定数组形参：
#+BEGIN_EXAMPLE
  // three equivalent definitions of printValues
  void printValues(int*) { /* ... */ }
  void printValues(int[]) { /* ... */ }
  void printValues(int[10]) { /* ... */ }
#+END_EXAMPLE

**** 形参的长度会引起误解
编译器忽略为任何数组形参指定的长度。定义长度会导致越界。

当编译器检查数组形参关联的实参时,它只会检查实参是不是指针、指针的类型和数组元素的类型时是否匹配,而不会检查数组的长度。

**** 数组实参
数组形参可定义为引用或非引用类型。大部分情况下,数组以普通的非引用类型传递,此时数组会悄悄地转换为指针。一般来说,非引用
类型的形参会初始化为其相应实参的副本。而在传递数组时,实参是指向数组第一个元素的指针,形参复制的是这个指针的值,而不是数组
元素本身。函数操纵的是指针的副本,因此不会修改实参指针的值。然而,函数可通过该指针改变它所指向的数组元素的值。通过指针形
参做的任何改变都在修改数组元素本身

*NOTE:* 
#+BEGIN_EXAMPLE
不需要修改数组形参的元素时,函数应该将形参定义为指向 const 对象的指针
#+END_EXAMPLE


**** 多维数组的传递
和其他数组一样,多维数组以指向 0 号元素的指针方式传递。多维数组的元素本身就是数组。除了第一维以外的所有维的长度都是元素类型的
一部分,必须明确指定：
#+BEGIN_EXAMPLE
  // first parameter is an array whose elements are arrays of 10 ints
  void printValues(int (matrix*)[10], int rowSize);
#+END_EXAMPLE
上面的语句将 matrix 声明为指向含有 10 个 int 型元素的数组的指针。

*** main： 处理命令行选项
主函数的实参是可选的,用来确定程序要执行的操作。

*** 含有可变形参的函数

** return 语句
return 语句用于结束当前正在执行的函数,并将控制权返回给调用此函数的函数。return 语句有两种形式:

#+BEGIN_EXAMPLE
return;
return expression;
#+END_EXAMPLE

*** 没有返回值的函数
不带返回值的 return 语句只能用于返回类型为 void 的函数。在返回类型为 void 的函数中,return 返回语句不是必需的,隐式的 return 发生在函数
的最后一个语句完成时。

*** 具有返回值的函数
return 语句的第二种形式提供了函数的结果。任何返回类型不是 void 的函数必须返回一个值,而且这个返回值的类型必须和函数的返回类型相同,或者
能隐式转化为函数的返回类型。

**** 主函数 main 的返回值
返回类型不是 void 的函数必须返回一个值,但此规则有一个例外情况:允许主函数 main 没有返回值就可结束。如果程序控制执行到主函数 main 的最后
一个语句都还没有返回,那么编译器会隐式地插入返回 0 的语句。

**** 返回非引用类型
函数的返回值用于初始化在调用函数处创建的临时对象。

**** 返回引用
当函数返回引用类型时,没有复制返回值。相反,返回的是对象本身。

**** 千万不要返回局部变量的引用
理解返回引用至关重要的是:千万不能返回局部变量的引用。

**** 引用返回左值

**** 千万不要返回指向局部对象的指针

*** 递归

** 函数声明
函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口。

**** 在头文件中提供函数声明
变量可在头文件中声明,而在源文件中定义。同理,函数也应当在头文件中声明,并在源文件中定义。

*** 默认实参
默认实参是通过给形参表中的形参提供明确的初始值来指定的。

**** 默认实参的初始化
既可以在函数声明也可以在函数定义中指定默认实参。但是,在一个文件中,只能为一个形参指定默认实参一次。

** 局部对象
在 C++ 语言中,每个名字都有作用域,而每个对象都有生命期。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。

*** 自动变量
默认情况下,局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象。局部变量所对应的自动对象在函数控制经过变量定义语句时创建。

*** 静态局部对象
一个变量如果位于函数的作用域内,但生命期跨越了这个函数的多次调用,这种变量往往很有用。则应该将这样的对象定义为 static(静态的)。

static 局部对象确保不迟于在程序执行流程第一次经过该对象的定义语句时进行初始化。这种对象一旦被创建,在程序结束前都不会撤销。

** 内联函数
返回两个 string 形参中较短的字符串的函数:
#+BEGIN_SRC c

  const string &shorterString(const string &s1, const string &s2)
  {
    return s1.size() < s2.size() ? s1 : s2;
  }
#+END_SRC

为这么一个小操作定义一个函数的好处是：
 + 阅读和理解函数 shorterString 的调用，要比读一条用等价的条件表示式取代函数调用表示式并解释它的含义要容易的多。
 + 如果需要做任何修改,修改函数要比找出并修改每一处等价表达式容易得多
 + 使用函数可以确保统一的行为,每个测试都保证以相同的方式实现。
 + 函数可以重用,不必为其他应用重写代码。

*但是* 将 shorterString 写成函数有一个潜在的缺点:调用函数比求解等价表达式要慢得多。

所以 *inline 函数避免函数调用的开销*

一般来说,内联机制适用于优化小的、只有几行的而且经常被调用的函数。大多数的编译器都不支持递归函数的内联。一个 1200 行的函数也不太可能在调用点内联展开。

*** 把 inline 函数放在头文件中
内联函数应该在头文件中定义,这一点不同于其他函数。inline 函数的定义对编译器而言必须是可见的,以便编译器能够在调用点内联展开该函数的代码。此时,仅有函数原型是不够的。

在头文件中加入或修改 inline 函数时,使用了该头文件的所有源文件都必须重新编译。

** 类的成员函数
成员函数的定义和普通函数的定义类似。和任何函数一样，成员函数也包含下面的四个部分：
 + 函数返回类型
 + 函数名
 + 用逗号隔开的形参表
 + 包含在一对花括号里面的函数体

前面三部分组成函数原型。函数原型定义了所有和函数相关的类型信息:函数返回类型是什么、函数的名字、应该给这个函数传递什么类型的
实参。函数原型必须在类中定义。但是,函数体则既可以在 *类中* 也可以在 *类外* 定义。


*** 定义成员函数的函数体
类的成员函数既可以在类的定义内也可以在类的定义外定义。

类的成员函数可以访问该类的 private 成员。


**** 成员函数含有额外的、隐含的形参

**** this 指针的引入
每个成员函数(除static成员函数)都有一个额外的、隐含的形参 this。在调用成员函数时,形参 this 初始化为调用函数的对象的地址。

**** const 成员函数的引入
const 改变了隐含的 this 形参的类型。用这种方式使用 const 的函数称为常量成员函数。由于 this 是指向 const 对象的指针,const 成员函数不能修改调用该函数的对象。
#+BEGIN_QUOTE
const 对象、指向 const 对象的指针或引用只能用于调用其const 成员函数,如果尝试用它们来调用非 const 成员函数,则是错误的。
#+END_QUOTE

**** this 指针的使用
在成员函数中,不必显式地使用 this 指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用,都被假定为通过指针 this 实现的引用

由于 this 指针是隐式定义的,因此不需要在函数的形参表中包含 this 指针,实际上,这样做也是非法的。但是,在函数体中可以显式地使用 this 指针。

*** 在类外定义成员函数
在类的定义外面定义成员函数必须指明它们是类的成员

*** 编写 Sales_item 类的构造函数
构造函数： 在定义类的时候初始化其数据成员的函数

**** 构造函数是特殊的成员函数
*构造函数* 是特殊的成员函数， 与其他成员函数不同，构造函数和类同名，并且没有返回类型。而与其他成员函数相同的是,构造函数也有形参表(可能为空)和
函数体。一个类可以有多个构造函数,每个构造函数必须有与其他构造函数不同数目或类型的形参。

构造函数的形参指定了创建类类型对象时使用的初始化式。通常,这些初始化式会用于初始化新创建对象的数据成员。构造函数通常应确保其每个数据成员都完成了初始化。

**** 构造函数的定义
和其他成员的函数一样，构造函数也必须在类中声明，但是可以在类中或者类外定义。
通常， 构造函数是放在类的 *public* 部分的。话说不是public 由毛线用。

**** 构造函数和初始化列表
在冒号和花括号之间的代码称为构造函数的初始化列表。构造函数的初始化列表为类的一个或多个数据成员指定初值。它跟在构造函数的形参表之后,以冒号开
关。构造函数的初始化式是一系列成员名,每个成员后面是括在圆括号中的初始值。多个成员的初始化用逗号分隔。

**** 合成的默认构造函数
#+BEGIN_QUOTE
如果没有为一个类显式定义任何构造函数,编译器将自动为这个类生成默认构造函数。
#+END_QUOTE

由编译器创建的默认构造函数通常称为默认构造函数,它将依据如同变量初始化的规则初始化类中所有成员。

#+BEGIN_QUOTE
合成的默认构造函数一般适用于仅包含类类型成员的类。而对于含有内置类型或复合类型成员的类,则通常应该定义他们自己的默认构造函数初始化这些成员。
#+END_QUOTE

*** 类代码文件的组织

** 重载函数
出现在相同作用域中的两个函数,如果具有相同的名字而形参表不同,则称为重载函数。

*函数重载和重复声明的区别*
如果两个函数声明的返回类型和形参表完全匹配,则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同,但返回类型不同,则第二个声明是错误的。

*** 重载和作用域
在函数中局部声明的名字将屏蔽在全局作用域内声明的同名名字。

一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数,则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。
#+BEGIN_QUOTE
在 C++ 中,名字查找发生在类型检查之前。
#+END_QUOTE

*** 函数匹配和实参转换
函数重载确定,即函数匹配是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较,
编译器实现该调用与函数的匹配。匹配结果有三种可能:
 + 编译器找到与实参最佳匹配的函数,并生成调用该函数的代码。
 + 找不到形参与函数调用的实参匹配的函数,在这种情况下,编译器将给出编译错误信息。
 + 存在多个与实参匹配的函数,但没有一个是明显的最佳选择。这种情况也是,该调用具有二义性。


*** 重载确定的三个步骤

**** 候选函数
函数重载确定的第一步是确定该调用所考虑的重载函数集合,该集合中的函数称为候选函数。
候选函数是与被调函数同名的函数,并且在调用点上,它的声明可见。

**** 选择可行函数
第二步是从候选函数中选择一个或多个函数,它们能够用该调用中指定的实参来
调用。因此,选出来的函数称为可行函数。可行函数必须满足两个条件:第一,
函数的形参个数与该调用的实参个数相同;第二,每一个实参的类型必须与对应
形参的类型匹配,或者可被隐式转换为对应的形参类型。

#+BEGIN_QUOTE
如果函数具有默认实参,则调用该函数时,所用的实参可能比实际需要的少。默认实参也是实参,在函数匹配过程中,它的处理方式与其他实参一样。
#+END_QUOTE

**** 寻找最佳匹配

**** 含有多个形参的重载确定
编译器通过依次检查每一个实参来决定哪个或哪些函数匹配最佳。如果有且仅有一个函数满足下列条件,则匹配成功：
1. 其每个实参的匹配都不劣于其他可行函数需要的匹配。
2. 至少有一个实参的匹配优于其他可行函数提供的匹配。

*** 实参类型转换

** 指向函数的指针
函数指针是指指向函数而非指向对象的指针。像其他指针一样,函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定,而与函数名无关。

*用 typedef 简化函数指针的定义*
函数指针类型相当地冗长。使用 typedef 为指针类型定义同义词,可将函数指针的使用大大简化

*指向函数的指针的初始化和赋值*

*通过指针调用函数*

*函数指针形参*

函数的形参可以是指向函数的指针。


*返回指向函数的指针*
函数可以返回指向函数的指针

*指向重载函数的指针*
