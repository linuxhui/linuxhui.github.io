* 概述
面向对象的关键思想在于多态(polymorphism)。
** 继承
通过继承，我们可定义一些类，这些类共享公共模型，仅仅特化本质上不通的东西。
派生类(derived class)能够继承基类(base class)定义的成员.

因继承而相关联的类构成了一个继承层次。其中一个类成为根，其它类直接或间接继承根类。

*NOTE*
在C++中，基类必须之处希望派生类重写那些函数，定义为virtual的函数是积累

** 定义基类和派生类

*** 定义基类 
和其他类一样，基类也有定义其接口和实现的数据和函数成员。

protected访问标号，以及对于析构函数和 保留关键字 virtual。

**** 基类成员函数
基类定义带有保留字 virtual的函数。保留字virtual 的目的是启用动态绑定。程序默认使用非虚函数，
对于非虚函数的调用在编译时确定。 为了指明函数为虚函数,在其返回类型前面加上保留字 virtual。除
了构造函数之外,任意非 static 成员函数都可以是虚函数。保留字只在类内部的成员函数声明中出现,不能用在类定义体外部出现的函数定义上。


基类通常应将派生类需要重定义的任意函数定义为虚函数。

**** 访问控制和继承
在基类中,public 和 private 标号具有普通含义:用户代码可以访问类的
public 成员而不能访问 private 成员,private 成员只能由基类的成员和友元
访问。派生类对基类的 public 和 private 成员的访问权限与程序中任意其他
部分一样:它可以访问 public 成员而不能访问 private 成员。

有时作为基类的类具有一些成员,它希望允许派生类访问但仍禁止其他用户
访问这些成员。对于这样的成员应使用受保护的访问标号。protected 成员可以
被派生类对象访问但不能被该类型的普通用户访问。

*** protected 成员
可以这么认为 protected 访问标号是 private 和 public 的混合。
  + 像 private 成员一样， protected 成员不能被类的用户访问。
  + 像 public 成员一样， protected 成员可被该类的派生类访问。

此外 protected 还有另外一个重要的性质：
  + 派生类只能通过派生类对象访问其基类的 protected 成员，派生类对其基类类型对象的protected 
成员没有特殊访问权限。

*NOTE：*
#+BEGIN_QUOTE
如果没有继承,类只有两种用户:类本身的成员和该类的用户。将类划
分为 private 和 public 访问级别反映了用户种类的这一分隔:用户只
能访问 public 接口,类成员和友元既可以访问 public 成员也可以访
问 private 成员。
有了继承,就有了类的第三种用户:从类派生定义新类的程序员。派生
类的提供者通常(但并不总是)需要访问(一般为 private 的)基类实
现,为了允许这种访问而仍然禁止对实现的一般访问,提供了附加的
protected 访问标号。类的 protected 部分仍然不能被一般程序访问,
但可以被派生类访问。只有类本身和友元可以访问基类的 private 部
分,派生类不能访问基类的 private 成员。
#+END_QUOTE

*** 派生类 
为了定义派生类,使用类派生列表指定基类。类派生列表指定了一个或多个
基类,具有如下形式:
#+BEGIN_EXAMPLE
   class classname: access-label base-class
#+END_EXAMPLE

这里 access-label 是 public、protected 或 private,base-class 是已
定义的类的名字。类派生列表可以指定多个基类。

**** 定义派生类

**** 派生类和虚函数
尽管不是必须这样做,派生类一般会重定义所继承的虚函数。派生类没有重定义某个虚函数,则使用基类中定义的版本。

派生类型必须对于想要重定义的每个继承成员进行声明。
派生类中虚函数的声明(第 7.4 节)必须与基类中的定义方式完全匹配,但有一个例外:返回对基类型的引用(或指针)的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用(或指针)。
#+BEGIN_QUOTE
一旦函数在基类中声明为虚函数,它就一直为虚函数,派生类
无法改变该函数为虚函数这一事实。派生类重定义虚函数时,
可以使用 virtual 保留字,但不是必须这样做。
#+END_QUOTE

**** 派生类对象包含基类对象作为子对象
派生类对象由多个部分组成： 派生类本身定义的(非 static)成员加上由基类 (非 static)对象组成的子对象。

**** 派生类中的函数可以使用基类的成员
像任意成员函数一样,派生类函数可以在类的内部或外部定义。

**** 用作基类的类必须是已经定义的
已定义的类才可以用作基类。如果已经声明了 Item_base 类,但没有定义它,则不能用 Item_base 作基类。

这一限制的原因应该很容易明白:每个派生类包含并且可以访问其基类的成员,为了使用这些成员,派生类必须知道它们是什么。这一规则暗示着不可能从类自身派生出一个类。

**** 用派生类作基类
基类本身可以是一个派生类

每个类继承其基类的所有成员。最底层的派生类继承其基类的成员,基类又继承自己的基类的成员,如此沿着继承链依次向上。从效果来说,最底层的派生类对象包含其每个直接基类和间接基类的子对象。


**** 派生类的声明：

*** virtual 和其他成员函数


