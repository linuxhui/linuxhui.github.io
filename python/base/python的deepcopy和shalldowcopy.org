* python的引用
python中的一切事物皆为对象，并且规定参数的传递都是对象的引用。

+ python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值——相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象——相当于通过“传值”来传递对象
+ 当人们复制列表或字典时，就复制了对象列表的引用同，如果改变引用的值，则修改了原始的参数。
+ 为了简化内存管理，Python通过引用计数机制实现自动垃圾回收功能，Python中的每个对象都有一个引用计数，用来计数该对象在不同场所分别被引用了多少次。每当引用一次Python对象，相应的引用计数就增1，每当消毁一次Python对象，则相应的引用就减1，只有当引用计数为零时，才真正从内存中删除Python对象。



python的参数传递有什么特殊的？看例子：

#+BEGIN_SRC python
  >>> seq = [1, 2, 3] 
  >>> seq_2 = seq 
  >>> seq_2.append(4) 
  >>> print seq, seq_2 [1, 2, 3, 4] [1, 2, 3, 4] 
  >>> seq.append(5) 
  >>> print seq, seq_2 [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]
#+END_SRC
* python的copy对象
Python中的对象之间赋值时是按引用传递的，如果需要拷贝对象，需要使用标准库中的copy模块。
+ copy.copy 浅拷贝，只拷贝父对象，不会拷贝对象的内部的子对象。
+ copy.deepcopy 深拷贝， 拷贝对象及其子对象。


** copy
创建新的复合对象并通过引用复制x的成员来创建x的浅复制。更加深层次说，
它复制了对象,但对于对象中的元素,依然使用引用。
对于内置类型，此函数并不经常使用。
而是使用诸如list(x), dict(x), set(x)等调用方式来创建x的浅复制，要知道像这样
直接使用类型名显然比使用copy()快很多。但是它们达到的效果是一样的。
还有一点就是对于那些不可修改的对象(string, 数字, 元组)，因为你不用担心修改他们。

** deepcopy
通过创建新的复合对象并重复复制x的所有成员来创建x的深复制。
visit是一个可选的字典，目的是跟踪受访问的对象，从而检测和避免重复定义
的数据结构中的循环。

尽管通常情况下不需要，但是通过实现方法__copy__(self)和__deepcopy__(self, visit)，
类就可以实现自定义的复制方法，这两个方法分别实现了浅复制和深复制操作。
__deepcopy__()方法必须使用字典visit，用来在复制过程中跟踪前面遇到的对象。对于
__deepcopy__()方法，除了将visit传到实现中包含的其他deepcopy()方法(如果有的话)之外，
没有必要在执行其他操作。

如果类实现了pickle模块所用的方法__getstate__()和__setstate__()，那么copy模块将使用
这些方法来创建副本。
，但是通过实现方法__copy__(self)和__deepcopy__(self, visit)，
类就可以实现自定义的复制方法，这两个方法分别实现了浅复制和深复制操作。
__deepcopy__()方法必须使用字典visit，用来在复制过程中跟踪前面遇到的对象。对于
__deepcopy__()方法，除了将visit传到实现中包含的其他deepcopy()方法(如果有的话)之外，
没有必要在执行其他操作。

如果类实现了pickle模块所用的方法__getstate__()和__setstate__()，那么copy模块将使用
这些方法来创建副本。，但是通过实现方法__copy__(self)和__deepcopy__(self, visit)，
类就可以实现自定义的复制方法，这两个方法分别实现了浅复制和深复制操作。
__deepcopy__()方法必须使用字典visit，用来在复制过程中跟踪前面遇到的对象。对于
__deepcopy__()方法，除了将visit传到实现中包含的其他deepcopy()方法(如果有的话)之外，
没有必要在执行其他操作。

如果类实现了pickle模块所用的方法__getstate__()和__setstate__()，那么copy模块将使用
这些方法来创建副本。
#+BEGIN_SRC python
  >>> a = [[1], ['a'], ['A']]
  >>> import copy
  >>> b = copy.deepcopy(a)
  >>> b
  [[1], ['a'], ['A']]
  >>> c = copy.copy(a)
  >>> c
  [[1], ['a'], ['A']]
  >>> a[1].append('b')
  >>> a
  [[1], ['a', 'b'], ['A']]
  >>> b
  [[1], ['a'], ['A']]
  >>> c
  [[1], ['a', 'b'], ['A']]
#+END_SRC



** 需要注意的是
(1)  copy模块用于像整数和字符串这样的简单类型，不过很少需要这么做。
(2)   这些复制函数无法与模块、类对象、函数、方法、回溯、栈帧、文件、套接字和其他类似类型同时工作。
如果不能复制对象，则会引发copy.error异常。

